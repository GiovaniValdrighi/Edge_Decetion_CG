<!DOCTYPE html>
<html>
<head>
	<title> Projeto A1 </title>
	<!comment: MathJax para equações matemáticas em TeX>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
	</script>
</head>

<body>
	<h1> Implementação da detectação de arestas de Canny</h1>
	

	<h3>Leitura e escrita de imagens com Canvas</h3>

	<figure>
		<canvas id="imagemOriginal" width="900" height="600"></canvas>
		<canvas id="imagemOutput" width="900" height="600"></canvas>
		<figcaption>
			Imagem da esquerda: Original. Imagem da direita: Imagem processada.
		</figcaption>
	</figure>


<script>
	var canvasOriginal = document.getElementById("imagemOriginal");
	var ctxOriginal = canvasOriginal.getContext("2d");
	
	var canvasOut = document.getElementById("imagemOutput");
	var ctxOutput = canvasOut.getContext("2d");
	
	var imgOriginal = new Image();
	var imgDataOut = new Image();

//It seems that firefox does not allow you to use getImageData(...) unless the source of the canvas is from the same domain, 
//and it does not consider files on your hard drive as being from the same domain as an html document also on your hard drive.	
//https://developpaper.com/explain-how-to-solve-the-cross-domain-problem-of-canvas-image-getimagedata-todataurl/
	imgOriginal.crossOrigin = '';
	imgDataOut.crossOrigin = '';
	
    imgOriginal.src = 'https://i.imgur.com/dfZONkf.jpg';
    imgOriginal.onload = function(){
		ctxOriginal.drawImage(imgOriginal, 0, 0);
		ctxOutput.drawImage(imgOriginal, 0, 0);
		//ctxOutput.drawImage(imgOriginal, 50, 50);
		//ctxOutput.drawImage(imgOriginal, 100, 100);
		
		imgDataOut = ctxOriginal.getImageData(0, 0, 1000	, 600);
		var dataCopy = new Uint8ClampedArray(imgDataOut.data);
		var height = imgDataOut.height;
		var width = imgDataOut.width;
		
		// invert colors
		//for (let i = 0; i < imgDataOut.data.length; i += 4) {
			//imgDataOut.data[i] = 255 - imgDataOut.data[i];
			//imgDataOut.data[i+1] = 255 - imgDataOut.data[i+1];
			//imgDataOut.data[i+2] = 255 - imgDataOut.data[i+2];
			//imgDataOut.data[i+3] = 255;
		//}
		
		function array_to_img(array, imgData){
			for(let i = 0; i<imgData.length; i +=4){
				imgData[i] = array_img[Math.floor(i/(width*4))][Math.floor(i/(height*4))];
				imgData[i +1] = imgData[i];
				imgData[i +2] = imgData[i];
				imgData[i +3] = 255;
			}
			return imgData
		}
		
		function black_n_white(imgData){
			//creating empty array
			array_img = new Array(height);
			console.log(array_img.length);
			for (let i = 0; i < array_img.length; i++){
				array_img[i] = new Array(width);
			}
			//use the mean of the 3 chanels
			console.log(width);
			for (let i = 0; i < imgData.length; i += 4){
				array_img[Math.floor(i/(width *4))][Math.floor(i/(height *4))] = (imgData[i] + imgData[i+1] + imgData[i+2])/3	
			}
			return array_img;
		}
	
		
		function gaussian_filter(imgData){
			save = new Uint8ClampedArray(imgData);
			for (let i = 0; i < 4*width*height; i += 4){
							
				imgData[i] = (41* save[i]
				+ 1*(save[i + (-8) + (-4*width*2)] || save[i])
				+ 4*(save[i + (-4) + (-4*width*2)] || save[i])
				+ 7*(save[i + (0) + (-4*width*2)] || save[i])
				+ 4*(save[i + (4) + (-4*width*2)] || save[i])
				+ 1*(save[i + (8) + (-4*width*2)] || save[i])
				+ 4*(save[i + (-8) + (-4*width)] || save[i])
				+ 16*(save[i + (-4) + (-4*width)] || save[i])
				+ 26*(save[i + (0) + (-4*width)] || save[i])
				+ 16*(save[i + (4) + (-4*width)] || save[i])
				+ 4*(save[i + (8) + (-4*width)] || save[i])
				+ 7*(save[i + (-8)] || save[i])
				+ 26*(save[i + (-4)] || save[i])
				+ 26*(save[i + (4)] || save[i])
				+ 7*(save[i + (8)] || save[i])
				+ 1*(save[i + (-8) + (4*width*2)] || save[i])
				+ 4*(save[i + (-4) + (4*width*2)] || save[i])
				+ 7*(save[i + (0) + (4*width*2)] || save[i])
				+ 4*(save[i + (4) + (4*width*2)] || save[i])
				+ 1*(save[i + (8) + (4*width*2)] || save[i])
				+ 4*(save[i + (-8) + (4*width)] || save[i])
				+ 16*(save[i + (-4) + (4*width)] || save[i])
				+ 26*(save[i + (0) + (4*width)] || save[i])
				+ 16*(save[i + (4) + (4*width)] || save[i])
				+ 4*(save[i + (8) + (4*width)] || save[i])
				)/273;
								
				imgData[i+1] = imgData[i];
				imgData[i+2] = imgData[i];
			}
			return imgData;
		}
		
		function arrayMax(arr) {
			var len = arr.length, max = -Infinity;
			while (len--) {
				if (arr[len] > max) {
					max = arr[len];
				}
			}
		return max;
		};


		function sobel_detector(imgData){
			//gx = new Uint8ClampedArray(imgData);
			new_data = [];
			for (let i = 0; i < 4*width*height; i += 4){
			
				gx = 
				- (imgData[i - 4 - 4*width] || 0)
				+ (imgData[i + 4 - 4*width] || 0)
				-2 * (imgData[i -4] || 0)
				+2 * (imgData[i +4] || 0)
				- (imgData[i -4 + 4*width] || 0)
				+ (imgData[i + 4 + 4*width] || 0);
				
				gy = 
				(imgData[i - 4 - 4*width] || 0)
				+ 2* (imgData[i - 4*width] || 0)
				+ (imgData[i + 4 - 4*width] || 0)
				- (imgData[i - 4 + 4*width] || 0)
				- 2* (imgData[i + 4 *width] || 0)
				- (imgData[i + 4 + 4*width] || 0);
				
				new_data.push(Math.sqrt((gx*gx) + (gy*gy)));
			}
			
			
			max_imgData = arrayMax(new_data);
			console.log(max_imgData);
			for (let i = 0; i < 4*width*height; i += 4){
				imgData[i] = Math.round(imgData[i] * 255 / max_imgData);
				imgData[i+1] = imgData[i];
				imgData[i+2] = imgData[i];
			}	
			return imgData;
		}
		
		imgDataOut.data.set(array_to_img(black_n_white(dataCopy), imgDataOut.data));
		
		//recuperar a imagem orignal
		//imgDataOut.data.set(dataCopy);
		ctxOutput.putImageData(imgDataOut, 0, 0);		
};	    
</script>


</body>
</html>