<!DOCTYPE html>
<html>
<head>
	<title> Projeto A1 </title>
	<!comment: MathJax para equações matemáticas em TeX>
	
	<link rel="stylesheet" type="text/css" href="style.css">
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
	
</head>

<body>
	<div id = "fundo">
	<div id = "topo">
	<h1 id = "titulo">Algoritmo de detectação de aresta - Canny</br> 
	Introdução a Computação Gráfica<h1>
	<h3 id = "autor">Giovani de Almeida Valdrighi<h3>

	</div>
	<div id = "barra_topo"></div>
	<div id = "corpo">
	<h2>Detectação de aresta</h3>
	<p> A detectação de aresta é um processo com o objetivo de encontrar mudanças bruscas no brilho ou na cor da imagem, matemáticamente falando, as suas descontinuidades, essas arestas podem significar mudanças de profundidade, iluminação, material. É frequentemente utilizada como pré-processamento para a seleção de características em imagens a serem utilizadas em processos de machine learn pois simplifica o conteúdo do imagem, capturando apenas o essencial, os "objetos" presentes nela.</p>
	<img src = "arara-azul.jpg" id = "arara"></img> <img src = "arara-azul-edge.jpg" id = "arara"></img>
	<p>Os critérios para um algoritmo adequado para a detecção de arestas são:</p>
	<ul>
		<li>Detecção de arestas com uma baixa taxa de erro, ou seja, o algoritmo deve encontrar o máximo de arestas presentes na imagem.</li>
		<li>A aresta detectada deve se encontrar exatamente no meio da aresta real (arestas em imagens podem possuir expessura).</li>
		<li>Uma aresta só deve ser detectada uma única vez, e ruídos não devem ser considerados arestas.</li>
	</ul>
	<p>Existem dois grupos de algoritmos de detectação de arestas: 'search based' e 'zero-crossing based'. [colocar aqui explicação]</p>
	
	<h2>Algoritmo Canny</h2>
	<p>Considerado um dos melhores algoritmos para detectação de aresta atualmente existentes, foi criado pelo cientista da computação John Canny em 1986. O algoritmo funciona em etapas, que são as seguintes: </p>
	<ol>
		<li>Transformação da imagem para a escala de cinza.</li>
		<li>Aplicação de um filtro de desfoque para diminuir o ruído presente, geralmente utilizado o filtro Gaussiano.</li>
		<li>Cálculo do gradiente horizontal e vertical utilizando o kernel de Sobel.</li>
		<li>Supressão de não-máximos para obter a presença da maior variação dentro da aresta.</li>
		<li>Limpeza de arestas considerando um limite minímo e máximo de intensidade.</li>
	</ol>
	<p>A seguir iremos tratar indidualmente cada um desses processos.</p>
	<h3>Escala de cinza</h3>
	<p>Apesar de existirem adaptações do algoritmo que considera os 3 canais de cores, trabalhar com um único canal (todos os canais possuem valores idênticos) torna o processamento mais rápido e também é suficiente para a aplicação do algoritmo, pois considerar as arestas com base no tom de cinza retorna um resultado adequado.</p>
	<p>Para tornar a imagem em preto e branco iremos simplesmente caminhar por cada pixel e calcular a média entre os 3 canais (RGB) e substituir este valor nos canais.</p>
	<button type="button" id = "bt-grayscale">Grayscale</button>
	<button type="button" id = "btr-grayscale">Retornar</button>
	<figure>
		<canvas id="ariranha-original" width="360" height = "490"></canvas>
		<canvas id="ariranha-preto-branco" width="360" height="490"></canvas>
	</figure>
	<h3>Desfoque Gaussiano</h3>
	<p>O próximo passo é a utilização de algum efeito de desfoque para tratar o ruído presente na imagem, pois o erro do ruído será distribuído entre os pixels ao redor, não possuindo assim um grande gradiente. Neste algoritmo iremos utilizar o filtro Gaussiano, cada pixel da imagem se tornará a média ponderada dos pixels ao seu redor, só que os pesos seguiram uma distribuição gaussiana. Note que a na distribuição gaussian, todo pixel da imagem teria um peso diferente de zero, no entanto, podemos considerar apenas os pesos até 2 desvio padrões, pois os demais se aproximarão muito de 0.</p>
	<p>Iremos utilizar a média igual a 0 e a variância é um parâmetro ajustável do algoritmo, podemos encontrar resultados finais melhores variando a variância da distribuição, nessa situação iremos utilizar o valor 1. Além disso, note que os nossos pixels formam uma matriz discreta, devemos portanto também discretizar nossa distribuição. </p>
	<button type = "button" id = "bt-gaussian">Gaussian</button>
	<button type = "button" id = "btr-gaussian">Retornar</button>
	<figure>
		<canvas id = "ariranha-preto-branco2" width="360" height="490"></canvas>
		<canvas id = "ariranha-gaussian" width="360" height="490"></canvas>
	</figure>
	</div>
	</div>
	<script src = "script.js"></script>
</body>
</html>